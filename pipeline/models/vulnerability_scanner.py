import re
import logging
from typing import List, Dict, Union

class VulnerabilityScanner:
    """
    Scans text or files for common security vulnerability signatures using Regex.
    """

    # Comprehensive Regex Patterns for common attacks
    PATTERNS = {
        "SQL Injection (SQLi)": [
            r"UNION\s+SELECT",
            r"OR\s+1=1",
            r"DROP\s+TABLE",
            r"--",
            r"OR\s+'1'='1'",
            r"SELECT\s+\*\s+FROM",
            r"WaitForDelay",
            r"pg_sleep"
        ],
        "Cross-Site Scripting (XSS)": [
            r"<script>",
            r"javascript:",
            r"onerror=",
            r"onload=",
            r"alert\(",
            r"document\.cookie",
            r"\"><img src=x"
        ],
        "Path Traversal (LFI/RFI)": [
            r"\.\./",
            r"\.\.\\",
            r"/etc/passwd",
            r"c:\\windows\\system32",
            r"boot\.ini",
            r"win\.ini"
        ],
        "Brute Force / Auth Failure": [
            r"Failed password",
            r"authentication failure",
            r"invalid user",
            r"Too many authentication failures",
            r"Brute check"
        ],
        "Command Injection": [
            r";\s*cat\s+",
            r"\|\s*nc\s+",
            r"\|\s*bash",
            r"&&\s*wget",
            r"&&\s*curl"
        ]
    }

    def __init__(self):
        self.compiled_patterns = self._compile_patterns()

    def _compile_patterns(self) -> Dict[str, List[re.Pattern]]:
        """Pre-compile regex patterns for performance."""
        compiled = {}
        for category, patterns in self.PATTERNS.items():
            compiled[category] = [re.compile(p, re.IGNORECASE) for p in patterns]
        return compiled

    def scan_text(self, text: str) -> List[Dict[str, Union[str, int]]]:
        """
        Scans a text buffer for vulnerabilities.
        
        Returns:
            List of findings: [{"type": "SQLi", "line": 0, "content": "match"}]
        """
        findings = []
        lines = text.split('\n')
        
        for i, line in enumerate(lines):
            line_idx = i + 1
            for category, patterns in self.compiled_patterns.items():
                for pattern in patterns:
                    if pattern.search(line):
                        findings.append({
                            "type": category,
                            "line": line_idx,
                            "content": line.strip()[:200]  # Truncate for display
                        })
                        # Break after first match per line per category to avoid spam
                        break 
                        
        return findings

    def scan_file(self, filepath: str) -> List[Dict[str, Union[str, int]]]:
        """Scans a specific file for vulnerabilities."""
        findings = []
        try:
            with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
                findings = self.scan_text(content)
                
            if findings:
                logging.warning(f"⚠️ Found {len(findings)} potential vulnerabilities in {filepath}")
            else:
                logging.info(f"✅ No vulnerabilities found in {filepath}")
                
        except Exception as e:
            logging.error(f"❌ Failed to scan {filepath}: {e}")
            
        return findings

# Usage Example
if __name__ == "__main__":
    scanner = VulnerabilityScanner()
    test_text = "User admin failed password\nSELECT * FROM users WHERE id=1 OR 1=1"
    print(scanner.scan_text(test_text))
